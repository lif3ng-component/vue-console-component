(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{365:function(e,n,t){"use strict";t.r(n),n.default='<template>\n  <div>\n    <nq-switch :togglePromiseFn="toggle" v-model="v" />\n    <p>\n      mock 异步请求<input v-model="remoteSuccess" type="checkbox" />{{\n        remoteSuccess ? "能" : "不能"\n      }}成功\n    </p>\n  </div>\n</template>\n<script>\nexport default {\n  data() {\n    return {\n      remoteV: true,\n      v: true,\n      remoteSuccess: true\n    };\n  },\n  methods: {\n    mockSet(v) {\n      return new Promise((resolve, reject) => {\n        setTimeout(() => {\n          if (this.remoteSuccess) {\n            this.remoteV = v;\n            resolve("success");\n          }\n          reject(new Error("remote save error"));\n        }, 1000);\n      });\n    },\n    mockGet() {\n      return new Promise((resolve, reject) => {\n        setTimeout(() => {\n          resolve(this.remoteV);\n        }, 1000);\n      });\n    },\n    // async 写法\n    // async toggle(value) {\n    //   try {\n    //     await this.mockSet(value);\n    //     this.$message("修改成功");\n    //   } catch (e) {\n    //     this.$message.error(e.message);\n    //     throw e;\n    //   }\n    //   return;\n    // },\n    // promise 写法\n    toggle(value) {\n      return this.mockSet(value)\n        .then(() => {\n          this.$message("修改成功");\n        })\n        .catch(e => {\n          this.$message.error(e.message);\n          // 必须保持 rejected 状态，以保证不切换 switch 状态\n          throw e;\n        });\n      // 单字段修改不应该重新请求数据\n      // .then(this.mockGet)\n      // .then(v => {\n      //   console.log(`客户端值:${this.v},响应值:${v}`);\n      // });\n    }\n  }\n};\n<\/script>'}}]);